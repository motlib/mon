from datetime import datetime
import logging


class CollectorBase():
    def __init__(self, cfg, interval=None):
        self._cfg = cfg

        if 'interval' in cfg:
            self._interval = cfg['interval']
        elif interval != None:
            self._interval = interval
        else:
            self._interval = 30
            
        # Create dict used for rates calculation.
        self._rates = {}
            
        # this will raise exceptions, if the collector requirements are not
        # fullfilled.
        self.check()

        
    def get_interval(self):
        return self._interval
        

    def check(self):
        # this function can be overridden to check if all preconditions for this
        # collector are fullfilled to be used. E.g. check if commands are available
        pass


    def get_class_name(self):
        return self.__class__.__name__

    
    def get_data(self):
        topic = self._cfg.get('topic', self.get_class_name())
        values = self._get_values()

        values['_class'] = self.get_class_name()

        # JSON usually uses isoformat (generated by datetime.now().isoformat()),
        # but this cannot be converted back to datetime object with standard
        # python, so we use unix timestamps
        values['_timestamp'] = int(datetime.utcnow().timestamp())
        
        values['_interval'] = self.get_interval()
        
        return (topic, values)


    def _get_rate(self, key, value):
        '''Helper function to calculate a rate from a counting value. E.g. useful for
        getting the throughput form a network device total bytes transferred
        value.

        Example:
        > _get_rate('example', 12)
        0

        # 3 seconds later, returns (18-12)/3
        > _get_rate('example', 18)
        2.0

        :param key: identifying the rate to be calculated.
        :param value: New (counter type) value to use for rate calculation.

        :return: On first call, always returns 0. On further calls returns the
        average change per second of the value parameter between calls. .

        '''
        
        if key in self._rates:
            secs = (datetime.now() - self._rates[key]['time']).total_seconds()

            rate = (value - self._rates[key]['value']) / secs
        else:
            self._rates[key] = {}
            rate = 0

        self._rates[key]['value'] = value
        self._rates[key]['time'] = datetime.now()

        return rate

    
    def __str__(self):
        '''Simple conversion to string, returning the class name.'''
        
        return self.get_class_name()
